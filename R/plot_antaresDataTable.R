# Copyright © 2016 RTE Réseau de transport d’électricité

#' plot time series contained in an antaresDataTable
#' 
#' This function generates an interactive plot of an antares Time series.
#' 
#' @param x
#'   Object of class \code{antaresDataTable}.
#' @param variable
#'   Name of the variable to plot. If this argument is missing, then the 
#'   function starts a shiny gadget that let the user choose the variable to
#'   represent. When the user clicks on the "Done" button", the graphic is
#'   returned by the function.
#' @param elements
#'   Vector of "element" names indicating for which elements of 'x' should the
#'   variable be plotted. For instance if the input data contains areas, then
#'   this parameter should be a vector of area names. If data contains clusters
#'   data, this parameter has to be the concatenation of the area name and the
#'   cluster name, separated by \code{" > "}. This is to prevent confusion 
#'   when two clusters from different areas have the same name.
#' @param type
#'   Type of plot to draw. "ts" creates a time series plot, "barplot" creates
#'   a barplot with one bar per element representing the average value of the
#'   variable for this element. "monotone" draws the monotone curve of the 
#'   variable for each element.
#' @param dateRange
#'   A vector of two dates. Only data points between these two dates are 
#'   displayed. If NULL, then all data is displayed.
#' @param confInt
#'   Number between 0 and 1 indicating the size of the confidence interval to 
#'   display. If it equals to 0, then confidence interval is not computed nor
#'   displayed. Used only when multiple Monte Carlo scenarios are present in 
#'   the input data.
#' @param maxValue
#'   Only used if parameter \code{type} is "density" or "cdf". If this parameter 
#'   is set, all values not in [-maxValue, maxValue] are removed from the graphic.
#'   This is useful to deal with variables containing a few extreme values
#'   (generally cost and price variables). If \code{maxValue} is 0 or unset, all
#'   values are displayed.
#' @param colors
#'   Vector of colors
#' @param ylab
#'   Label of the Y axis.
#' @param ...
#'   currently unused
#' @inheritParams productionStack
#'   
#' @return 
#' The function returns an object of class "htmlwidget". It is generated by
#' package \code{highcharter} if time step is annual or by \code{dygraphs} for 
#' any other time step.It can be directly displayed in the viewer or be stored
#' in a variable for later use.
#' 
#' @details 
#' If the input data contains several Monte-Carlo scenarios, the function will
#' display the evolution of the average value. Moreover it will represent a
#' 95% confidence interval.
#' 
#' If the input data has a annual time step, the function creates a barplot
#' instead of a line chart.
#' 
#' 
#' @examples 
#' \dontrun{
#' setSimulationPath()
#' mydata <- readAntares("all", timeStep = "monthly")
#' plot(mydata)
#' plot(mydata, "LOAD")
#' 
#' # Plot only a few areas
#' plot(mydata[area %in% c("area1", "area2", "area3")])
#' 
#' # If data contains detailed results, then the function adds a confidence
#' # interval
#' dataDetailed <- readAntares("all", timeStep = "monthly", synthesis = FALSE)
#' plot(dataDetailed)
#' 
#' # If the time step is annual, the function creates a barplot instead of a
#' # linechart
#' dataAnnual <- readAntares("all", timeStep = "Annual")
#' plot(dataAnnual)
#' 
#' }
#'
#' @export
plot.antaresDataTable <- function(x, variable = NULL, elements = NULL, 
                                  type = c("ts", "barplot", "monotone", "density", "cdf"),
                                  dateRange = NULL,
                                  confInt = 0,
                                  minValue = NULL,
                                  maxValue = NULL,
                                  interactive = base::interactive(),
                                  colors = NULL,
                                  main = NULL,
                                  ylab = NULL,
                                  legend = TRUE,
                                  legendItemsPerRow = 5,
                                  width = NULL, height = NULL, ...) {
  
  type <- match.arg(type)
  idCols <- .idCols(x)
  valueCols <- setdiff(names(x), idCols)
  timeStep <- attr(x, "timeStep")
  dataname <- deparse(substitute(x))
  showConfInt <- !is.null(x$mcYear) && length(unique(x$mcYear) > 1)
  
  # Prepare data for plotting
  dt <- x[, .(
    time = .timeIdToDate(timeId, timeStep, simOptions(x)), 
    value = 0)
    ]
  
  if ("cluster" %in% idCols) {
    dt$element <- paste(x$area, x$cluster, sep = " > ")
  } else if ("district" %in% idCols) {
    dt$element <- x$district
  } else if ("link" %in% idCols) {
    dt$element <- x$link
  } else if ("area" %in% idCols) {
    dt$element <- x$area
  } else stop("No Id column")
  
  if ("mcYear" %in% names(x) && length(unique(x$mcYear)) > 1) {
    dt$mcYear <- x$mcYear
  }
  
  dataDateRange <- as.Date(range(dt$time))
  if (is.null(dateRange) || length(dateRange) < 2) dateRange <- dataDateRange
  
  
  # Function that generates the desired graphic.
  plotFun <- function(dt, variable, elements, type, confInt, dateRange, minValue, maxValue) {
    if (is.null(variable)) variable <- valueCols[1]
    dt$value <- x[, get(variable)]
    if (length(elements) > 0 & !"all" %in% elements) dt <- dt[element %in% elements]
    dt <- dt[as.Date(time) %between% dateRange]
    f <- switch(type,
                "ts" = .plotTS,
                "barplot" = .barplot,
                "monotone" = .plotMonotone,
                "density" = .density,
                "cdf" = .cdf,
                stop("Invalid type")
    )
    f(
      dt, 
      timeStep = timeStep, 
      variable = variable, 
      confInt = confInt, 
      minValue = minValue,
      maxValue = maxValue, 
      colors = colors, 
      main = main, 
      ylab = ylab, 
      legend = legend, 
      legendItemsPerRow = legendItemsPerRow, 
      width = width, 
      height = height
    )
    
  }
  
  # If not in interactive mode, generate a simple graphic, else create a GUI
  # to interactively explore the data
  if (!interactive) {
    return(plotFun(dt, variable, elements, type, confInt, dateRange, minValue, maxValue))
  }
  
  uniqueElem <- sort(as.character(unique(dt$element)))
  if (is.null(elements)) {
    elements <- uniqueElem
    if (length(elements) > 5) elements <- elements[1:5]
  }
  
  if (timeStep == "annual") {
    type <- "barplot"
    typeChoices <- "barplot"
  } else {
    typeChoices <- c("time series" = "ts", "barplot", "monotone", "density", "cdf")
  }
  
  manipulateWidget(
    plotFun(dt, variable, elements, type, confInt, dateRange, minValue, maxValue),
    variable = mwSelect(valueCols, variable),
    type = mwSelect(c("time series" = "ts", "barplot", "monotone", "density", "cdf"), type),
    dateRange = mwDateRange(dateRange, min = dataDateRange[1], max = dataDateRange[2]),
    confInt = mwSlider(0, 1, confInt, step = 0.01, label = "confidence interval"),
    minValue = mwNumeric(NULL, "min value"),
    maxValue = mwNumeric(NULL, "max value"),
    elements = mwSelect(c("all", uniqueElem), elements, multiple = TRUE),
    .main = dataname,
    .display = list(confInt = showConfInt,
                    minValue = type %in% c("density", "cdf"),
                    maxValue = type %in% c("density", "cdf"),
                    dateRange = timeStep != "annual",
                    type = timeStep != "annual")
  )
  
}

#' Private function that draws a given time series for each element
#' 
#' @param dt
#'   data.table created by .prepareDataForPlot
#' @param timeStep
#'   Time step of the data
#' @param main
#'   Title of the plot
#' @param ylab
#'   Label of the y-axis
#' @param confInt
#'   A number between 0 and 1 indicating the size of the confidence interval to
#'   display If NULL, then confidence intervals are not computed and displayed.
#' 
#' @return dygraphwidget object.
#' 
#' @noRd
#' 
.plotTS <- function(dt, timeStep, variable, confInt = 0, maxValue, 
                    colors = NULL,
                    main = NULL,
                    ylab = NULL,
                    legend = TRUE,
                    legendItemsPerRow = 5,
                    width = NULL, height = NULL, ...) {
  
  uniqueElements <- sort(unique(dt$element))
  plotConfInt <- FALSE
  
  # If dt contains several Monte-Carlo scenario, compute aggregate statistics
  if (!is.null(dt$mcYear)) {
    if (confInt == 0) {
      
      dt <- dt[, .(value = mean(value)), by = .(element, time)]
      
    } else {
      
      plotConfInt <- TRUE
      alpha <- (1 - confInt) / 2
      dt <- dt[, .(value = c(mean(value), quantile(value, c(alpha, 1 - alpha))),
                   suffix = c("", "_l", "_u")), 
               by = .(time, element)]
      dt[, element := paste0(element, suffix)]
    }
  }
  
  dt <- dcast(dt, time ~ element, value.var = "value")
  
  # Graphical parameters
  if (is.null(ylab)) ylab <- variable
  if (is.null(main)) main <- paste("Evolution of", variable)
  if (is.null(colors)) {
    colors <- substring(rainbow(length(uniqueElements), s = 0.7, v = 0.7), 1, 7)
  } else {
    colors <- rep(colors, length.out = length(uniqueElements))
  }
  
  legendId <- sample(1e9, 1)
  
  g <- dygraph(dt, main = main, group = legendId) %>% 
    dyOptions(
      includeZero = TRUE, 
      gridLineColor = gray(0.8), 
      axisLineColor = gray(0.6), 
      axisLabelColor = gray(0.6), 
      labelsKMB = TRUE,
      colors = colors 
    ) %>% 
    dyAxis("x", rangePad = 10) %>% 
    dyAxis("y", label = ylab, pixelsPerLabel = 60, rangePad = 10) %>% 
    #dyRangeSelector() %>% 
    dyLegend(show = "never") %>% 
    dyCallbacks(
      highlightCallback = JS_updateLegend(legendId, timeStep),
      unhighlightCallback = JS_resetLegend(legendId)
    )
  
  if (plotConfInt) {
    for (v in uniqueElements) {
      g <- g %>% dySeries(paste0(v, c("_l", "", "_u")))
    }
  }
  
  if (legend) {
    l <- tsLegend(uniqueElements, types = rep("line", length(uniqueElements)), 
                  colors = colors, legendId = legendId, legendItemsPerRow = legendItemsPerRow)
  } else l <- NULL
  
  
  combineWidgets(g, footer = l, width = width, height = height)
  
}

#' Private function that draw a barplot
#' 
#' The resulting barplot contains a bar per element which represents the average
#' value over time steps.
#' 
#' @noRd 
#'  
.barplot <- function(dt, timeStep, variable, confInt = 0, maxValue,
                     colors = NULL,
                     main = NULL,
                     ylab = NULL,
                     legend = TRUE,
                     legendItemsPerRow = 5,
                     width = NULL, height = NULL, ...) {
  
  if (is.null(dt$mcYear)) {
    dt <- dt[, .(value = mean(value)), by = element] 
  } else {
    dt <- dt[, .(value = mean(value)), by = .(element, mcYear)] 
    
    if (confInt == 0) {
      dt <- dt[, .(value = mean(value)), by = .(element)]
    } else {
      uniqueElements <- sort(unique(dt$element))
      
      alpha <- (1 - confInt) / 2
      dt <- dt[, .(value = c(mean(value), quantile(value, c(alpha, 1 - alpha))),
                   suffix = c("", "_l", "_u")), 
               by = .(element)]
      dt[, element := paste0(element, suffix)]
    }
  }
  
  if (is.null(ylab)) ylab <- variable
  if (is.null(main)) main <- paste("Comparison of", variable)
  
  g <- highchart() %>%
    hc_yAxis(title = list(text = ylab)) %>% 
    hc_legend(enabled = FALSE) %>% 
    hc_title(text = main)
  
  if (!exists("uniqueColvar")) {
    g <- g %>% hc_xAxis(categories = dt$element) %>%
      hc_add_series(name = variable, data = dt$value, type = "column") 
  } else {
    g <- g %>% hc_xAxis(categories = dt[suffix == "", colvar]) %>%
      hc_add_series(name = variable, data = dt[suffix == "", value], type = "column") %>% 
      hc_add_series(name = "range", 
                    data = cbind(dt[suffix == "_l", value], dt[suffix == "_u", value]), 
                    type = "errorbar")
  }
  
  combineWidgets(g, width = width, height = height)
}

.plotMonotone <- function(dt, timeStep, variable, confInt = NULL, maxValue,
                          main = NULL, ylab = NULL, ...) {
  
  uniqueElements <- sort(unique(dt$element))
  plotConfInt <- FALSE
  # If dt contains several Monte-Carlo scenario, compute aggregate statistics
  if (is.null(dt$mcYear)) {
    dt <- dt[, .(
      x = 1:length(value),
      y = sort(value, decreasing = TRUE)
    ), by = element]
  } else {
    dt <- dt[, .(
      x = 1:length(value),
      y = sort(value, decreasing = TRUE)
    ), by = .(element, mcYear)]
    
    if (confInt == 0) {
      dt <- dt[, .(y = mean(y)), by = .(element, x)]
    } else {
      plotConfInt <- TRUE
      uniqueElements <- sort(unique(dt$element))
      
      alpha <- (1 - confInt) / 2
      dt <- dt[, .(y = c(mean(y), quantile(y, c(alpha, 1 - alpha))),
                   suffix = c("", "_l", "_u")), 
               by = .(x, element)]
      dt[, element := paste0(element, suffix)]
    }
  }
  
  if (is.null(ylab)) ylab <- variable
  if (is.null(main)) main <- paste("Monotone of", variable)
  
  .plotStat(dt, ylab = ylab, main = main, uniqueElements = uniqueElements, ...)
  
}

.density <- function(dt, timeStep, variable, minValue = NULL, maxValue = NULL, 
                     main = NULL, ylab = NULL, ...) {
  
  uniqueElements <- sort(unique(dt$element))
  
  xbins <- .getXBins(dt$value, minValue, maxValue)
  if (is.character(xbins)) return(xbins)
  
  .getDensity <- function(x) {
    dens <- density(x, from = xbins$rangeValues[1], to = xbins$rangeValues[2])
    data.table(x = signif(dens$x, xbins$nsignif), y = dens$y)
  }
  
  dt <- dt[, .getDensity(value), by = element]
  
  if (is.null(ylab)) ylab <- "Density"
  if (is.null(main)) main <- paste("Density of", variable)
  
  .plotStat(dt, ylab = ylab, main = main, uniqueElements = uniqueElements, ...)
  
}

.cdf <- function(dt, timeStep, variable, minValue = NULL, maxValue = NULL,
                 main = NULL, ylab = NULL, ...) {
  
  uniqueElements <- sort(unique(dt$element))
  
  xbins <- .getXBins(dt$value, minValue, maxValue)$xbins
  
  .getCDF <- function(x) {
    cdf <- sapply(xbins, function(y) mean(x <= y))
    data.table(x = xbins, y = cdf)
  }
  
  dt <- dt[, .getCDF(value), by = element]
  
  if (is.null(ylab)) ylab <- "Proportion of time steps"
  if (is.null(main)) main <- paste("Cumulated distribution of", variable)
  
  .plotStat(dt, ylab = ylab, main = main, uniqueElements = uniqueElements, ...)
  
}

.getXBins <- function(values, minValue = NULL, maxValue = NULL, size = 512) {
  if (is.null(minValue) || is.na(minValue)) {
    minValue <- min(values)
  }
  
  if (is.null(maxValue) || is.na(maxValue)) {
    maxValue <- max(values)
  }
  
  if (minValue >= maxValue) {
    return("No value to display. Please change values of minValue or unset them to display all values")
  }
  
  rangeValues <- c(minValue, maxValue)
  
  # Get the correct number of significant digits
  offset <- diff(rangeValues) * 0.1
  rangeValues <- c(rangeValues[1] - offset, rangeValues[2] + offset)
  xbins <- seq(rangeValues[1], rangeValues[2], length.out = 512)
  nsignif <- 3
  
  while(any(duplicated(signif(xbins, nsignif)))) nsignif <- nsignif + 1
  
  list(xbins = signif(xbins, nsignif), nsignif = nsignif, rangeValues = rangeValues)
}

.plotStat <- function(dt, ylab, main, colors, uniqueElements, 
                      legend, legendItemsPerRow, width, height,
                      plotConfInt = FALSE, ...) {
  dt <- dcast(dt, x ~ element, value.var = "y")
  
  if (is.null(colors)) {
    colors <- substring(rainbow(length(uniqueElements), s = 0.7, v = 0.7), 1, 7)
  } else {
    colors <- rep(colors, length.out = length(uniqueElements))
  }
  
  legendId <- sample(1e9, 1)
  
  g <- dygraph(dt, main = main, group = legendId) %>% 
    dyOptions(
      includeZero = TRUE, 
      colors = colors,
      gridLineColor = gray(0.8), 
      axisLineColor = gray(0.6), 
      axisLabelColor = gray(0.6), 
      labelsKMB = TRUE
    ) %>% 
    dyAxis("y", label = ylab, pixelsPerLabel = 60) %>% 
    dyLegend(show = "never") %>% 
    dyCallbacks(
      highlightCallback = JS_updateLegend(legendId, timeStep = "none"),
      unhighlightCallback = JS_resetLegend(legendId)
    )
  
  if (plotConfInt) {
    for (v in uniqueElements) {
      g <- g %>% dySeries(paste0(v, c("_l", "", "_u")))
    }
  }
  
  if (legend) {
    l <- tsLegend(uniqueElements, types = rep("line", length(uniqueElements)), 
                  colors = colors, legendId = legendId, legendItemsPerRow = legendItemsPerRow)
  } else l <- NULL
  
  
  combineWidgets(g, footer = l, width = width, height = height)
}
