#' plot time series contained in an antaresDataTable
#' 
#' This function generates an interactive plot of an antares Time series.
#' 
#' @param x
#'   Object of class \code{antaresDataTable}.
#' @param variable
#'   Name of the variable to plot. If this argument is missing, then the 
#'   function starts a shiny gadget that let the user choose the variable to
#'   represent. When the user clicks on the "Done" button", the graphic is
#'   returned by the function.
#' @param main
#'   Title of the generated graphic
#' @param ylab
#'   label of the "y" axis
#' @param ...
#'   currently unused
#'   
#' @return 
#' The function returns an object of class "htmlwidget". It is generated by
#' package \code{highcharter} if time step is annual or by \code{dygraphs} for 
#' any other time step.It can be directly displayed in the viewer or be stored
#' in a variable for later use.
#' 
#' @details 
#' If the input data contains several Monte-Carlo scenarios, the function will
#' display the evolution of the average value. Moreover it will represent a
#' 95% confidence interval.
#' 
#' If the input data has a annual time step, the function creates a barplot
#' instead of a line chart.
#' 
#' 
#' @examples 
#' \dontrun{
#' setSimulationPath()
#' mydata <- readAntares("all", timeStep = "monthly")
#' plot(mydata)
#' plot(mydata, "LOAD")
#' 
#' # Plot only a few areas
#' plot(mydata[area %in% c("area1", "area2", "area3")])
#' 
#' # If data contains detailed results, then the function adds a confidence
#' # interval
#' dataDetailed <- readAntares("all", timeStep = "monthly", synthesis = FALSE)
#' plot(dataDetailed)
#' 
#' # If the time step is annual, the function creates a barplot instead of a
#' # linechart
#' dataAnnual <- readAntares("all", timeStep = "Annual")
#' plot(dataAnnual)
#' 
#' }
#'
#' @export
plot.antaresDataTable <- function(x, variable, elements, 
                                  interactive = base::interactive(), ...) {
  if (missing(variable)) { # If missing variable start interactive mode
    res <- manipulateWidget(
      plot(x, variable, main = ""),
      variable = mwSelect(setdiff(names(x), .idCols(x))) 
    )
    return(res)
  }
  
  if (missing(ylab)) ylab <- variable
  
  idVars <- .idCols(x)
  timeStep <- attr(x, "timeStep")
  
  # Prepare data to plot
  # First, we construct a table with three columns:
  # - time: POSIXct or Date
  # - colvar: factor representing the name of each "element" in the input data.
  #           each element is represented with a different curve or bar in the
  #           final graphic.
  # - variable: values to visualize
  #
  # Then we reshape the data to have one line per date/time and one column per
  # "element". Cells contain the variable to visualize.
  dt <- x[, .(timeId, var = get(variable))]
  dt$time <- .timeIdToDate(dt$timeId, timeStep = timeStep)
  
  if ("cluster" %in% idVars) {
    dt$colvar <- paste(x$area, x$cluster)
  } else if ("district" %in% idVars) {
    dt$colvar <- x$district
  } else if ("link" %in% idVars) {
    dt$colvar <- x$link
  } else if ("area" %in% idVars) {
    dt$colvar <- x$area
  } else stop("No Id column")
  
  if ("mcYear" %in% names(x) && length(unique(x$mcYear)) > 1) {
    dt$mcYear <- x$mcYear
    
    uniqueColvar <- sort(unique(dt$colvar))
    
    dt <- dt[, .(var = c(mean(var), quantile(var, c(0.025, 0.975))),
                 suffix = c("", "_l", "_u")), 
             by = .(time, colvar)]
    dt[, colvar := paste0(colvar, suffix)]
  }
  
  if (timeStep != "annual") {
    # Plot time series curves, unless data is annual
    dt <- dcast(dt, time ~ colvar, value.var = "var")
    if (missing(main)) main <- paste("Evolution of", variable)
    
    g <- dygraph(dt, main = main) %>% 
      dyOptions(
        includeZero = TRUE, 
        gridLineColor = gray(0.8), 
        axisLineColor = gray(0.6), 
        axisLabelColor = gray(0.6), 
        labelsKMB = TRUE
      ) %>% 
      dyAxis("y", label = ylab, pixelsPerLabel = 60) %>% 
      dyRangeSelector()
    
    if (exists("uniqueColvar")) {
      for (v in uniqueColvar) {
        g <- g %>% dySeries(paste0(v, c("_l", "", "_u")))
      }
    }
    
  } else {
    # If data is annual, plot a barchart to compare elements
    if (missing(main)) main <- paste("Comparison of", variable)
    
    g <- highchart() %>%
      hc_yAxis(title = list(text = ylab)) %>% 
      hc_legend(enabled = FALSE) %>% 
      hc_title(text = main)
    
    if (!exists("uniqueColvar")) {
      g <- g %>% hc_xAxis(categories = dt$colvar) %>%
      hc_add_series(name = variable, data = dt$var, type = "column") 
    } else {
      g <- g %>% hc_xAxis(categories = dt[suffix == "", colvar]) %>%
        hc_add_series(name = variable, data = dt[suffix == "", var], type = "column") %>% 
        hc_add_series(name = "range", 
                     data = cbind(dt[suffix == "_l", var], dt[suffix == "_u", var]), 
                     type = "errorbar")
    }
  }
  
  g
}

#' Prepare the data for ploting
#' 
#' This function performs all data preparation required by all plotting functions
#' 
#' @param x
#'   antaresDataTable
#' @param variable
#'   Name of a column of x
#'   
#' @returns
#' data.table
.prepareDataForPlot <- function(x, variable) {
  idVars <- .idCols(x)
  dt <- x[, .(timeId, var = get(variable))]
  
  if ("cluster" %in% idVars) {
    dt$element <- paste(x$area, x$cluster)
  } else if ("district" %in% idVars) {
    dt$element <- x$district
  } else if ("link" %in% idVars) {
    dt$element <- x$link
  } else if ("area" %in% idVars) {
    dt$element <- x$area
  } else stop("No Id column")
  
  if ("mcYear" %in% names(x) && length(unique(x$mcYear)) > 1) {
    dt$mcYear <- x$mcYear
  }
  
  dt
}

#' Private function that draws a given time series for each element
#' 
#' @param dt
#'   data.table created by .prepareDataForPlot
#' @param timeStep
#'   Time step of the data
#' @param main
#'   Title of the plot
#' @param ylab
#'   Label of the y-axis
#' @param confInt
#'   A number between 0 and 1 indicating the size of the confidence interval to
#'   display If NULL, then confidence intervals are not computed and displayed.
#' 
#' @returns dygraphwidget object.
#' 
#' @noRd
#' 
.plotTS <- function(dt, timeStep, variable, confInt = NULL) {
  
  # If dt contains several Monte-Carlo scenario, compute aggregate statistics
  if (!is.null(dt$mcYear) && length(unique(dt$mcYear)) > 1) {
    if (is.null(confInt)) {
      
      dt <- dt[, .(var = mean(var)), by = .(element, timeId)]
      
    } else {
      
      uniqueElement <- sort(unique(dt$element))
      
      alpha <- (1 - confInt) / 2
      dt <- dt[, .(var = c(mean(var), quantile(var, c(alpha, 1 - alpha))),
                   suffix = c("", "_l", "_u")), 
               by = .(timeId, element)]
      dt[, element := paste0(element, suffix)]
    }
  }
  
  dt <- dcast(dt, timeId ~ element, value.var = "var")
  dt$timeId <- .timeIdToDate(dt$timeId, timeStep = timeStep)
  
  ylab <- variable
  main <- paste("Evolution of", variable)
  
  g <- dygraph(dt, main = main) %>% 
    dyOptions(
      includeZero = TRUE, 
      gridLineColor = gray(0.8), 
      axisLineColor = gray(0.6), 
      axisLabelColor = gray(0.6), 
      labelsKMB = TRUE
    ) %>% 
    dyAxis("y", label = ylab, pixelsPerLabel = 60) %>% 
    dyRangeSelector()
  
  if (exists("uniqueElement")) {
    for (v in uniqueElement) {
      g <- g %>% dySeries(paste0(v, c("_l", "", "_u")))
    }
  }
  g
}

#' Private function that draw a barplot
#' 
#' The resulting barplot contains a bar per element which represent the sum of
#' the value
#' 
.barplot <- function(dt, timeStep, variable, confInt = NULL) {
  if (is.null(dt$mcYear) || length(unique(dt$mcYear)) == 1) {
    dt <- dt[, .(var = sum(var)), by = element] 
  } else {
    dt <- dt[, .(var = sum(var)), by = .(element, mcYear)] 
    
    if (is.null(confInt)) {
      dt <- dt[, .(var = mean(var)), by = .(element)]
    } else {
      uniqueElement <- sort(unique(dt$element))
      
      alpha <- (1 - confInt) / 2
      dt <- dt[, .(var = c(mean(var), quantile(var, c(alpha, 1 - alpha))),
                   suffix = c("", "_l", "_u")), 
               by = .(element)]
      dt[, element := paste0(element, suffix)]
    }
  }
  
  ylab <- variable
  main <- paste("Comparison of", variable)
  
  g <- highchart() %>%
    hc_yAxis(title = list(text = ylab)) %>% 
    hc_legend(enabled = FALSE) %>% 
    hc_title(text = main)
  
  if (!exists("uniqueColvar")) {
    g <- g %>% hc_xAxis(categories = dt$element) %>%
      hc_add_series(name = variable, data = dt$var, type = "column") 
  } else {
    g <- g %>% hc_xAxis(categories = dt[suffix == "", colvar]) %>%
      hc_add_series(name = variable, data = dt[suffix == "", var], type = "column") %>% 
      hc_add_series(name = "range", 
                    data = cbind(dt[suffix == "_l", var], dt[suffix == "_u", var]), 
                    type = "errorbar")
  }
  
  g
}


