#' plot time series contained in an antaresDataTable
#' 
#' This function generates an interactive plot of an antares Time series.
#' 
#' @param x
#'   Object of class \code{antaresDataTable}.
#' @param variable
#'   Name of the variable to plot. If this argument is missing, then the 
#'   function starts a shiny gadget that let the user choose the variable to
#'   represent. When the user clicks on the "Done" button", the graphic is
#'   returned by the function.
#' @param elements
#'   Vector of "element" names indicating for which elements of 'x' should the
#'   variable be plotted. For instance if the input data contains areas, then
#'   this parameter should be a vector of area names. If data contains clusters
#'   data, this parameter has to be the concatenation of the area name and the
#'   cluster name, separated by \code{" > "}. This is to prevent confusion 
#'   when two clusters from different areas have the same name.
#' @param type
#'   Type of plot to draw. "ts" creates a time series plot, "barplot" creates
#'   a barplot with one bar per element representing the average value of the
#'   variable for this element. "monotone" draws the monotone curve of the 
#'   variable for each element.
#' @param dateRange
#'   A vector of two dates. Only data points between these two dates are 
#'   displayed. If NULL, then all data is displayed.
#' @param confInt
#'   Number between 0 and 1 indicating the size of the confidence interval to 
#'   display. If it equals to 0, then confidence interval is not computed nor
#'   displayed. Used only when multiple Monte Carlo scenarios are present in 
#'   the input data.
#' @param interactive
#'   Should the function start a shiny gadget that lets the user modify the
#'   parameters of the plot ?
#' @param colors
#'   Vector of colors
#' @param main
#'   Title of the generated graphic.
#' @param ylab
#'   label of the "y" axis.
#' @param legend
#'   Logical value indicating if a legend should be drawn.
#' @param legendItemsByRow
#'   Number of items to display in each row of the legend.
#' @param ...
#'   currently unused
#'   
#' @return 
#' The function returns an object of class "htmlwidget". It is generated by
#' package \code{highcharter} if time step is annual or by \code{dygraphs} for 
#' any other time step.It can be directly displayed in the viewer or be stored
#' in a variable for later use.
#' 
#' @details 
#' If the input data contains several Monte-Carlo scenarios, the function will
#' display the evolution of the average value. Moreover it will represent a
#' 95% confidence interval.
#' 
#' If the input data has a annual time step, the function creates a barplot
#' instead of a line chart.
#' 
#' 
#' @examples 
#' \dontrun{
#' setSimulationPath()
#' mydata <- readAntares("all", timeStep = "monthly")
#' plot(mydata)
#' plot(mydata, "LOAD")
#' 
#' # Plot only a few areas
#' plot(mydata[area %in% c("area1", "area2", "area3")])
#' 
#' # If data contains detailed results, then the function adds a confidence
#' # interval
#' dataDetailed <- readAntares("all", timeStep = "monthly", synthesis = FALSE)
#' plot(dataDetailed)
#' 
#' # If the time step is annual, the function creates a barplot instead of a
#' # linechart
#' dataAnnual <- readAntares("all", timeStep = "Annual")
#' plot(dataAnnual)
#' 
#' }
#'
#' @export
plot.antaresDataTable <- function(x, variable = NULL, elements = NULL, 
                                  type = c("ts", "barplot", "monotone"),
                                  dateRange = NULL,
                                  confInt = 0,
                                  interactive = base::interactive(),
                                  colors = NULL,
                                  main = NULL,
                                  ylab = NULL,
                                  legend = TRUE,
                                  legendItemsByRow = 5, ...) {
  
  type <- match.arg(type)
  idCols <- .idCols(x)
  valueCols <- setdiff(names(x), idCols)
  timeStep <- attr(x, "timeStep")
  dataname <- deparse(substitute(x))
  showConfInt <- !is.null(x$mcYear) && length(unique(x$mcYear) > 1)
  
  # Prepare data for plotting
  dt <- x[, .(
    time = .timeIdToDate(timeId, timeStep, simOptions(x)), 
    value = 0)
    ]
  
  if ("cluster" %in% idCols) {
    dt$element <- paste(x$area, x$cluster, sep = " > ")
  } else if ("district" %in% idCols) {
    dt$element <- x$district
  } else if ("link" %in% idCols) {
    dt$element <- x$link
  } else if ("area" %in% idCols) {
    dt$element <- x$area
  } else stop("No Id column")
  
  if ("mcYear" %in% names(x) && length(unique(x$mcYear)) > 1) {
    dt$mcYear <- x$mcYear
  }
  
  dataDateRange <- as.Date(range(dt$time))
  if (is.null(dateRange) || length(dateRange) < 2) dateRange <- dataDateRange
  
  
  # Function that generates the desired graphic.
  plotFun <- function(dt, variable, elements, type, confInt, dateRange) {
    if (is.null(variable)) variable <- valueCols[1]
    dt$value <- x[, get(variable)]
    if (length(elements) > 0 & !"all" %in% elements) dt <- dt[element %in% elements]
    dt <- dt[as.Date(time) %between% dateRange]
    f <- switch(type,
                "ts" = .plotTS,
                "barplot" = .barplot,
                "monotone" = .plotMonotone,
                stop("Invalid type")
    )
    f(dt, timeStep, variable, confInt = confInt, colors, main, ylab, legend, legendItemsByRow)
  }
  
  # If not in interactive mode, generate a simple graphic, else create a GUI
  # to interactively explore the data
  if (!interactive) {
    return(plotFun(dt, variable, elements, type, confInt, dateRange))
  }
  
  uniqueElem <- sort(as.character(unique(dt$element)))
  if (is.null(elements)) {
    elements <- uniqueElem
    if (length(elements) > 5) elements <- elements[1:5]
  }
  
  manipulateWidget(
    plotFun(dt, variable, elements, type, confInt, dateRange),
    variable = mwSelect(valueCols, variable),
    type = mwSelect(c("time series" = "ts", "barplot", "monotone"), type),
    dateRange = mwDateRange(dateRange, min = dataDateRange[1], max = dataDateRange[2]),
    confInt = mwSlider(0, 1, confInt, step = 0.01, label = "confidence interval"),
    elements = mwSelect(c("all", uniqueElem), elements, multiple = TRUE),
    .main = dataname,
    .display = list(confInt = showConfInt)
  )
  
}

#' Private function that draws a given time series for each element
#' 
#' @param dt
#'   data.table created by .prepareDataForPlot
#' @param timeStep
#'   Time step of the data
#' @param main
#'   Title of the plot
#' @param ylab
#'   Label of the y-axis
#' @param confInt
#'   A number between 0 and 1 indicating the size of the confidence interval to
#'   display If NULL, then confidence intervals are not computed and displayed.
#' 
#' @return dygraphwidget object.
#' 
#' @noRd
#' 
.plotTS <- function(dt, timeStep, variable, confInt = 0, colors = NULL,
                    main = NULL,
                    ylab = NULL,
                    legend = TRUE,
                    legendItemsByRow = 5) {
  
  uniqueElement <- sort(unique(dt$element))
  plotConfInt <- FALSE
  
  # If dt contains several Monte-Carlo scenario, compute aggregate statistics
  if (!is.null(dt$mcYear)) {
    if (confInt == 0) {
      
      dt <- dt[, .(value = mean(value)), by = .(element, time)]
      
    } else {
      
      plotConfInt <- TRUE
      alpha <- (1 - confInt) / 2
      dt <- dt[, .(value = c(mean(value), quantile(value, c(alpha, 1 - alpha))),
                   suffix = c("", "_l", "_u")), 
               by = .(time, element)]
      dt[, element := paste0(element, suffix)]
    }
  }
  
  dt <- dcast(dt, time ~ element, value.var = "value")
  
  # Graphical parameters
  if (is.null(ylab)) ylab <- variable
  if (is.null(main)) main <- paste("Evolution of", variable)
  if (is.null(colors)) {
    colors <- substring(rainbow(length(uniqueElement), s = 0.7, v = 0.7), 1, 7)
  } else {
    colors <- rep(colors, length.out = length(uniqueElement))
  }
  
  legendId <- sample(1e9, 1)
  
  g <- dygraph(dt, main = main, group = legendId) %>% 
    dyOptions(
      includeZero = TRUE, 
      gridLineColor = gray(0.8), 
      axisLineColor = gray(0.6), 
      axisLabelColor = gray(0.6), 
      labelsKMB = TRUE,
      colors = colors
    ) %>% 
    dyAxis("x", rangePad = 10) %>% 
    dyAxis("y", label = ylab, pixelsPerLabel = 60, rangePad = 10) %>% 
    dyRangeSelector() %>% 
    dyLegend(show = "never") %>% 
    dyCallbacks(
      highlightCallback = JS_updateLegend(legendId, timeStep),
      unhighlightCallback = JS_resetLegend(legendId)
    )
  
  if (plotConfInt) {
    for (v in uniqueElement) {
      g <- g %>% dySeries(paste0(v, c("_l", "", "_u")))
    }
  }
  
  if (!legend) return(g)
  
  l <-  tsLegend(uniqueElement, types = rep("line", length(uniqueElement)), 
                 colors = colors, legendId = legendId, itemsByRow = legendItemsByRow)
  g %>% htmlwidgets::onRender(JS_addLegend, list(size = l$attribs$height, 
                                                 html = htmltools::doRenderTags(l)))
  
}

#' Private function that draw a barplot
#' 
#' The resulting barplot contains a bar per element which represents the average
#' value over time steps.
#' 
#' @noRd 
#'  
.barplot <- function(dt, timeStep, variable, confInt = 0, colors = NULL,
                     main = NULL,
                     ylab = NULL,
                     legend = TRUE,
                     legendItemsByRow = 5) {
  
  if (is.null(dt$mcYear)) {
    dt <- dt[, .(value = mean(value)), by = element] 
  } else {
    dt <- dt[, .(value = mean(value)), by = .(element, mcYear)] 
    
    if (confInt == 0) {
      dt <- dt[, .(value = mean(value)), by = .(element)]
    } else {
      uniqueElement <- sort(unique(dt$element))
      
      alpha <- (1 - confInt) / 2
      dt <- dt[, .(value = c(mean(value), quantile(value, c(alpha, 1 - alpha))),
                   suffix = c("", "_l", "_u")), 
               by = .(element)]
      dt[, element := paste0(element, suffix)]
    }
  }
  
  if (is.null(ylab)) ylab <- variable
  if (is.null(main)) main <- paste("Comparison of", variable)
  
  g <- highchart() %>%
    hc_yAxis(title = list(text = ylab)) %>% 
    hc_legend(enabled = FALSE) %>% 
    hc_title(text = main)
  
  if (!exists("uniqueColvar")) {
    g <- g %>% hc_xAxis(categories = dt$element) %>%
      hc_add_series(name = variable, data = dt$value, type = "column") 
  } else {
    g <- g %>% hc_xAxis(categories = dt[suffix == "", colvar]) %>%
      hc_add_series(name = variable, data = dt[suffix == "", value], type = "column") %>% 
      hc_add_series(name = "range", 
                    data = cbind(dt[suffix == "_l", value], dt[suffix == "_u", value]), 
                    type = "errorbar")
  }
  
  g
}

.plotMonotone <- function(dt, timeStep, variable, confInt = NULL, colors = NULL,
                          main = NULL,
                          ylab = NULL,
                          legend = TRUE,
                          legendItemsByRow = 5) {
  
  uniqueElement <- sort(unique(dt$element))
  plotConfInt <- FALSE
  # If dt contains several Monte-Carlo scenario, compute aggregate statistics
  if (is.null(dt$mcYear)) {
    dt <- dt[, .(
      rank = 1:length(value),
      value = sort(value, decreasing = TRUE)
    ), by = element]
  } else {
    dt <- dt[, .(
      rank = 1:length(value),
      value = sort(value, decreasing = TRUE)
    ), by = .(element, mcYear)]
    
    if (confInt == 0) {
      dt <- dt[, .(value = mean(value)), by = .(element, rank)]
    } else {
      plotConfInt <- TRUE
      uniqueElement <- sort(unique(dt$element))
      
      alpha <- (1 - confInt) / 2
      dt <- dt[, .(value = c(mean(value), quantile(value, c(alpha, 1 - alpha))),
                   suffix = c("", "_l", "_u")), 
               by = .(rank, element)]
      dt[, element := paste0(element, suffix)]
    }
  }
  
  dt <- dcast(dt, rank ~ element, value.var = "value")
  
  if (is.null(ylab)) ylab <- variable
  if (is.null(main)) main <- paste("Monotone of", variable)
  if (is.null(colors)) {
    colors <- substring(rainbow(length(uniqueElement), s = 0.7, v = 0.7), 1, 7)
  } else {
    colors <- rep(colors, length.out = length(uniqueElement))
  }
  
  legendId <- sample(1e9, 1)
  
  g <- dygraph(dt, main = main, group = legendId) %>% 
    dyOptions(
      includeZero = TRUE, 
      colors = colors,
      gridLineColor = gray(0.8), 
      axisLineColor = gray(0.6), 
      axisLabelColor = gray(0.6), 
      labelsKMB = TRUE
    ) %>% 
    dyAxis("y", label = ylab, pixelsPerLabel = 60) %>% 
    dyLegend(show = "never") %>% 
    dyCallbacks(
      highlightCallback = JS_updateLegend(legendId, timeStep = "none"),
      unhighlightCallback = JS_resetLegend(legendId)
    )
  
  if (plotConfInt) {
    for (v in uniqueElement) {
      g <- g %>% dySeries(paste0(v, c("_l", "", "_u")))
    }
  }
  
  if (!legend) return(g)
  
  l <-  tsLegend(uniqueElement, types = rep("line", length(uniqueElement)), 
                 colors = colors, legendId = legendId, itemsByRow = legendItemsByRow)
  g %>% htmlwidgets::onRender(JS_addLegend, list(size = l$attribs$height, 
                                                 html = htmltools::doRenderTags(l)))
  
}
