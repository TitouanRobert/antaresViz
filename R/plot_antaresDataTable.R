# Copyright © 2016 RTE Réseau de transport d’électricité

#' plot time series contained in an antaresData object
#' 
#' This function generates an interactive plot of an antares time series.
#' 
#' @param x
#'   Object of class \code{antaresData}.
#' @param y
#'   Optional object of class \code{antaresData}. If it is specified, then two
#'   charts are generated.
#' @param table
#'   Name of the table to display when \code{x} is an \code{antaresDataList}
#'   object.
#' @param variable
#'   Name of the variable to plot. If this argument is missing, then the 
#'   function starts a shiny gadget that let the user choose the variable to
#'   represent. When the user clicks on the "Done" button", the graphic is
#'   returned by the function.
#' @param elements
#'   Vector of "element" names indicating for which elements of 'x' should the
#'   variable be plotted. For instance if the input data contains areas, then
#'   this parameter should be a vector of area names. If data contains clusters
#'   data, this parameter has to be the concatenation of the area name and the
#'   cluster name, separated by \code{" > "}. This is to prevent confusion 
#'   when two clusters from different areas have the same name.
#' @param type
#'   Type of plot to draw. "ts" creates a time series plot, "barplot" creates
#'   a barplot with one bar per element representing the average value of the
#'   variable for this element. "monotone" draws the monotone curve of the 
#'   variable for each element.
#' @param dateRange
#'   A vector of two dates. Only data points between these two dates are 
#'   displayed. If NULL, then all data is displayed.
#' @param confInt
#'   Number between 0 and 1 indicating the size of the confidence interval to 
#'   display. If it equals to 0, then confidence interval is not computed nor
#'   displayed. Used only when multiple Monte Carlo scenarios are present in 
#'   the input data.
#' @param maxValue
#'   Only used if parameter \code{type} is "density" or "cdf". If this parameter 
#'   is set, all values not in [-maxValue, maxValue] are removed from the graphic.
#'   This is useful to deal with variables containing a few extreme values
#'   (generally cost and price variables). If \code{maxValue} is 0 or unset, all
#'   values are displayed.
#' @param colors
#'   Vector of colors
#' @param ylab
#'   Label of the Y axis.
#' @param compare
#'   An optional character vector containing names of parameters. When it is set,
#'   two charts are outputed with their own input controls. Alternatively, it can
#'   be a named list with names corresponding to parameter names and values being
#'   list with the initial values of the given parameter for each chart.
#' @param compareLayout
#'   Only used if \code{y} or \code{compare} is not null. If it equals to "v", 
#'   then charts are placed one above the other. If it equals to "h", they are
#'   placed one next to the other.
#' @param ...
#'   currently unused
#' @inheritParams prodStack
#'   
#' @return 
#' The function returns an object of class "htmlwidget". It is generated by
#' package \code{highcharter} if time step is annual or by \code{dygraphs} for 
#' any other time step.It can be directly displayed in the viewer or be stored
#' in a variable for later use.
#' 
#' @details 
#' If the input data contains several Monte-Carlo scenarios, the function will
#' display the evolution of the average value. Moreover it will represent a
#' 95% confidence interval.
#' 
#' If the input data has a annual time step, the function creates a barplot
#' instead of a line chart.
#' 
#' 
#' @examples 
#' \dontrun{
#' setSimulationPath()
#' mydata <- readAntares("all", timeStep = "monthly")
#' plot(mydata)
#' plot(mydata, "LOAD")
#' 
#' # Plot only a few areas
#' plot(mydata[area %in% c("area1", "area2", "area3")])
#' 
#' # If data contains detailed results, then the function adds a confidence
#' # interval
#' dataDetailed <- readAntares("all", timeStep = "monthly", synthesis = FALSE)
#' plot(dataDetailed)
#' 
#' # If the time step is annual, the function creates a barplot instead of a
#' # linechart
#' dataAnnual <- readAntares("all", timeStep = "Annual")
#' plot(dataAnnual)
#' 
#' # Compare the results of two simulations
#' setSimulationPath(path1)
#' mydata1 <- readAntares("all", timeStep = "daily")
#' setSimulationPath(path2)
#' mydata2 <- readAntares("all", timeStep = "daily")
#' 
#' plot(mydata1, mydata2)
#' 
#' # Compare two periods for the same simulation
#' plot(mydata1, compare = "dateRange")
#' 
#' # Compare two Monte-Carlo scenarios
#' detailedData <- readAntares("all", mcYears = "all")
#' plot(detailedData[mcYear == 1], detailedData[mcYear == 2])
#' 
#' # To do the same thing, with antaresDataList objects, one can use 'subset'
#' detailedData <- readAntares(areas = "all" links = "all", mcYears = "all")
#' plot(subset(detailedData, mcYears = 1), subset(detailedData, mcYears = 2))
#' }
#' 
#' @export
plot.antaresDataTable <- function(x, y = NULL, variable = NULL, elements = NULL, 
                                  type = c("ts", "barplot", "monotone", "density", "cdf"),
                                  dateRange = NULL,
                                  confInt = 0,
                                  minValue = NULL,
                                  maxValue = NULL,
                                  compare = NULL,
                                  compareLayout = c("v", "h"),
                                  interactive = base::interactive(),
                                  colors = NULL,
                                  main = NULL,
                                  ylab = NULL,
                                  legend = TRUE,
                                  legendItemsPerRow = 5,
                                  width = NULL, height = NULL, ...) {
  .plotAntares(
    x,
    y = y,
    table = NULL, 
    variable = variable, 
    elements = elements,
    type = type,
    dateRange = dateRange,
    confInt = confInt,
    minValue = minValue,
    maxValue = maxValue,
    compare = compare,
    compareLayout = compareLayout,
    interactive = interactive,
    colors = colors, main = main, ylab = ylab, 
    legend = TRUE, legendItemsPerRow = legendItemsPerRow,
    width = width, height = height, 
    ...
  )
}

#' @rdname plot.antaresDataTable
#' @export
plot.antaresDataList <- function(x, y = NULL, table = NULL, variable = NULL, elements = NULL, 
                                  type = c("ts", "barplot", "monotone", "density", "cdf"),
                                  dateRange = NULL,
                                  confInt = 0,
                                  minValue = NULL,
                                  maxValue = NULL,
                                  compare = NULL,
                                  compareLayout = c("v", "h"),
                                  interactive = base::interactive(),
                                  colors = NULL,
                                  main = NULL,
                                  ylab = NULL,
                                  legend = TRUE,
                                  legendItemsPerRow = 5,
                                  width = NULL, height = NULL, ...) {
  .plotAntares(
    x, 
    y = y,
    table = NULL, 
    variable = variable, 
    elements = elements,
    type = type,
    dateRange = dateRange,
    confInt = confInt,
    minValue = minValue,
    maxValue = maxValue,
    compare = compare,
    compareLayout = compareLayout,
    interactive = interactive,
    colors = colors, main = main, ylab = ylab, 
    legend = TRUE, legendItemsPerRow = legendItemsPerRow,
    width = width, height = height, 
    ...
  )
}

.plotAntares <- function(x, y = NULL, table = NULL, variable = NULL, elements = NULL, 
                         type = c("ts", "barplot", "monotone", "density", "cdf"),
                         dateRange = NULL,
                         confInt = 0,
                         minValue = NULL,
                         maxValue = NULL,
                         compare = NULL,
                         compareLayout = c("v", "h"),
                         interactive = base::interactive(),
                         colors = NULL,
                         main = NULL,
                         ylab = NULL,
                         legend = TRUE,
                         legendItemsPerRow = 5,
                         width = NULL, height = NULL, ...) {
  
  type <- match.arg(type)
  timeStep <- attr(x, "timeStep")
  dataname <- deparse(substitute(x))
  compareLayout <- match.arg(compareLayout)
  
  if (is.null(compare)) {
    if (!is.null(y)) compare <- list()
  } else {
    if (is.character(compare)) {
      compare <- match.arg(
        compare, 
        c("table", "variable", "elements", "type", "dateRange", "minValue", "maxValue"),
        several.ok = TRUE
      )
      tmp <- lapply(compare, function(x) NULL)
      names(tmp) <- compare
      compare <- tmp
    }
  }
  
  
  .prepareParams <- function(x) {
    idCols <- .idCols(x)
    
    dt <- x[, .(
      time = .timeIdToDate(timeId, timeStep, simOptions(x)), 
      value = 0)
    ]
    
    if ("cluster" %in% idCols) {
      dt$element <- paste(x$area, x$cluster, sep = " > ")
    } else if ("district" %in% idCols) {
      dt$element <- x$district
    } else if ("link" %in% idCols) {
      dt$element <- x$link
    } else if ("area" %in% idCols) {
      dt$element <- x$area
    } else stop("No Id column")
    
    if ("mcYear" %in% names(x) && length(unique(x$mcYear)) > 1) {
      dt$mcYear <- x$mcYear
    }
    
    dataDateRange <- as.Date(range(dt$time))
    if (is.null(dateRange) || length(dateRange) < 2) dateRange <- dataDateRange
    
    uniqueElem <- sort(as.character(unique(dt$element)))
    if (is.null(elements)) {
      elements <- uniqueElem
      if (length(elements) > 5) elements <- elements[1:5]
    }
    
    list(
      dt = dt,
      idCols = idCols,
      valueCols = setdiff(names(x), idCols),
      showConfInt = !is.null(x$mcYear) && length(unique(x$mcYear) > 1),
      dataDateRange = dataDateRange,
      dateRange = dateRange,
      uniqueElem = uniqueElem,
      elements = elements
    )
  }
  
  if (is(x, "antaresDataTable")) {
    x <- as.antaresDataList(x)
  }
    
  params <- list(
    x = lapply(x, .prepareParams)
  )
  
  if (!is.null(y)) {
    if (!is(y, "antaresData")) stop("y should be an 'antaresData' object")
    y <- as.antaresDataList(y)
    params$y <- lapply(y, .prepareParams)
    x <- list(x, y)
  } else {
    params$y <- params$x
    x <- list(x, x)
  }
  
  # Function that generates the desired graphic.
  plotFun <- function(table, id, variable, elements, type, confInt, dateRange, minValue, maxValue) {
    if (is.null(variable)) variable <- params[[id]][[table]]$valueCols[1]
    if (is.null(dateRange)) dateRange <- params[[id]][[table]]$dateRange
    if (is.null(type) || is.null(table) || !variable %in% names(x[[id]][[table]])) {
      return(combineWidgets())
    }
    dt <- params[[id]][[table]]$dt
    
    dt$value <- x[[id]][[table]][, get(variable)]
    if (length(elements) == 0) {
      elements <- params[[id]][[table]]$uniqueElem[1:5]
    }
    if (!"all" %in% elements) dt <- dt[element %in% elements]
    dt <- dt[as.Date(time) %between% dateRange]
    
    if (nrow(dt) == 0) return(combineWidgets())
    
    f <- switch(type,
                "ts" = .plotTS,
                "barplot" = .barplot,
                "monotone" = .plotMonotone,
                "density" = .density,
                "cdf" = .cdf,
                stop("Invalid type")
    )
    f(
      dt, 
      timeStep = timeStep, 
      variable = variable, 
      confInt = confInt, 
      minValue = minValue,
      maxValue = maxValue, 
      colors = colors, 
      main = if(length(main) == 1) main else main[id], 
      ylab = if(length(ylab) == 1) ylab else ylab[id], 
      legend = legend, 
      legendItemsPerRow = legendItemsPerRow, 
      width = width, 
      height = height
    )
    
  }
  
  if (is.null(table)) table <- names(params[[1]])[1]
  # If not in interactive mode, generate a simple graphic, else create a GUI
  # to interactively explore the data
  if (!interactive) {
    return(plotFun(table, variable, elements, type, confInt, dateRange, minValue, maxValue))
  }
  
  if (timeStep == "annual") {
    type <- "barplot"
    typeChoices <- "barplot"
  } else {
    typeChoices <- c("time series" = "ts", "barplot", "monotone", "density", "cdf")
  }
  
  
  manipulateWidget(
    plotFun(table, .id, variable, elements, type, confInt, dateRange, minValue, maxValue),
    table = mwSelect(names(params[[1]]), value = table),
    variable = mwSelect(value = variable),
    type = mwSelect(c("time series" = "ts", "barplot", "monotone", "density", "cdf"), type),
    dateRange = mwDateRange(params[[1]][[table]]$dateRange),
    confInt = mwSlider(0, 1, confInt, step = 0.01, label = "confidence interval"),
    minValue = mwNumeric(minValue, "min value"),
    maxValue = mwNumeric(maxValue, "max value"),
    elements = mwSelect(value = elements, multiple = TRUE),
    .main = dataname,
    .display = list(table = length(params[[.id]]) > 1,
                    confInt = params[[.id]][[table]]$showConfInt,
                    minValue = type %in% c("density", "cdf"),
                    maxValue = type %in% c("density", "cdf"),
                    dateRange = timeStep != "annual",
                    type = timeStep != "annual"),
    .updateInputs = list(
      variable = list(choices = params[[.id]][[table]]$valueCols),
      elements = list(choices = c("all", params[[.id]][[table]]$uniqueElem)),
      dateRange = list(
        min = params[[.id]][[table]]$dataDateRange[1], 
        max = params[[.id]][[table]]$dataDateRange[2]
      )
    ),
    .compare = compare,
    .compareLayout = compareLayout
  )
  
}

#' Private function that draws a given time series for each element
#' 
#' @param dt
#'   data.table created by .prepareDataForPlot
#' @param timeStep
#'   Time step of the data
#' @param main
#'   Title of the plot
#' @param ylab
#'   Label of the y-axis
#' @param confInt
#'   A number between 0 and 1 indicating the size of the confidence interval to
#'   display If NULL, then confidence intervals are not computed and displayed.
#' 
#' @return dygraphwidget object.
#' 
#' @noRd
#' 
.plotTS <- function(dt, timeStep, variable, confInt = 0, maxValue, 
                    colors = NULL,
                    main = NULL,
                    ylab = NULL,
                    legend = TRUE,
                    legendItemsPerRow = 5,
                    width = NULL, height = NULL, ...) {
  
  uniqueElements <- sort(unique(dt$element))
  plotConfInt <- FALSE
  
  # If dt contains several Monte-Carlo scenario, compute aggregate statistics
  if (!is.null(dt$mcYear)) {
    if (confInt == 0) {
      
      dt <- dt[, .(value = mean(value)), by = .(element, time)]
      
    } else {
      
      plotConfInt <- TRUE
      alpha <- (1 - confInt) / 2
      dt <- dt[, .(value = c(mean(value), quantile(value, c(alpha, 1 - alpha))),
                   suffix = c("", "_l", "_u")), 
               by = .(time, element)]
      dt[, element := paste0(element, suffix)]
    }
  }
  
  dt <- dcast(dt, time ~ element, value.var = "value")
  
  # Graphical parameters
  if (is.null(ylab)) ylab <- variable
  if (is.null(main)) main <- paste("Evolution of", variable)
  if (is.null(colors)) {
    colors <- substring(rainbow(length(uniqueElements), s = 0.7, v = 0.7), 1, 7)
  } else {
    colors <- rep(colors, length.out = length(uniqueElements))
  }
  
  legendId <- sample(1e9, 1)
  
  g <- dygraph(dt, main = main, group = legendId) %>% 
    dyOptions(
      includeZero = TRUE, 
      gridLineColor = gray(0.8), 
      axisLineColor = gray(0.6), 
      axisLabelColor = gray(0.6), 
      labelsKMB = TRUE,
      colors = colors 
    ) %>% 
    dyAxis("x", rangePad = 10) %>% 
    dyAxis("y", label = ylab, pixelsPerLabel = 60, rangePad = 10) %>% 
    #dyRangeSelector() %>% 
    dyLegend(show = "never") %>% 
    dyCallbacks(
      highlightCallback = JS_updateLegend(legendId, timeStep),
      unhighlightCallback = JS_resetLegend(legendId)
    )
  
  if (plotConfInt) {
    for (v in uniqueElements) {
      g <- g %>% dySeries(paste0(v, c("_l", "", "_u")))
    }
  }
  
  if (legend) {
    l <- tsLegend(uniqueElements, types = rep("line", length(uniqueElements)), 
                  colors = colors, legendId = legendId, legendItemsPerRow = legendItemsPerRow)
  } else l <- NULL
  
  
  combineWidgets(g, footer = l, width = width, height = height)
  
}

#' Private function that draw a barplot
#' 
#' The resulting barplot contains a bar per element which represents the average
#' value over time steps.
#' 
#' @noRd 
#'  
.barplot <- function(dt, timeStep, variable, confInt = 0, maxValue,
                     colors = NULL,
                     main = NULL,
                     ylab = NULL,
                     legend = TRUE,
                     legendItemsPerRow = 5,
                     width = NULL, height = NULL, ...) {
  
  if (is.null(dt$mcYear)) {
    dt <- dt[, .(value = mean(value)), by = element] 
  } else {
    dt <- dt[, .(value = mean(value)), by = .(element, mcYear)] 
    
    if (confInt == 0) {
      dt <- dt[, .(value = mean(value)), by = .(element)]
    } else {
      uniqueElements <- sort(unique(dt$element))
      
      alpha <- (1 - confInt) / 2
      .getConfInt <- function(x) {
        q <- quantile(x, c(alpha, 1 - alpha))
        m <- mean(x)
        list(value = m, l = m - q[1], u = q[2] - m)
      }
      dt <- dt[, .getConfInt(value), by = .(element)]
    }
  }
  
  if (is.null(ylab)) ylab <- variable
  if (is.null(main)) main <- paste("Comparison of", variable)
  
  g <- plot_ly(dt) %>% 
    config(displayModeBar = FALSE) %>% 
    layout(title = main, yaxis = list(title = ylab))
  
  if (is.null(dt$l)) {
    g <- g %>% add_bars(x = ~element, y = ~value, alpha = 0.3)
  } else {
    g <- g %>% 
      add_bars(
        x = ~element, y = ~value, alpha = 0.3,
        error_y = ~list(
          type = "array",
          symmetric = FALSE,
          array = u,
          arrayminus = l
        )
      )
  }
  
  combineWidgets(g, width = width, height = height)
}

.plotMonotone <- function(dt, timeStep, variable, confInt = NULL, maxValue,
                          main = NULL, ylab = NULL, ...) {
  
  uniqueElements <- sort(unique(dt$element))
  plotConfInt <- FALSE
  # If dt contains several Monte-Carlo scenario, compute aggregate statistics
  if (is.null(dt$mcYear)) {
    dt <- dt[, .(
      x = 1:length(value),
      y = sort(value, decreasing = TRUE)
    ), by = element]
  } else {
    dt <- dt[, .(
      x = 1:length(value),
      y = sort(value, decreasing = TRUE)
    ), by = .(element, mcYear)]
    
    if (confInt == 0) {
      dt <- dt[, .(y = mean(y)), by = .(element, x)]
    } else {
      plotConfInt <- TRUE
      uniqueElements <- sort(unique(dt$element))
      
      alpha <- (1 - confInt) / 2
      dt <- dt[, .(y = c(mean(y), quantile(y, c(alpha, 1 - alpha))),
                   suffix = c("", "_l", "_u")), 
               by = .(x, element)]
      dt[, element := paste0(element, suffix)]
    }
  }
  
  if (is.null(ylab)) ylab <- variable
  if (is.null(main)) main <- paste("Monotone of", variable)
  
  .plotStat(dt, ylab = ylab, main = main, uniqueElements = uniqueElements, ...)
  
}

.density <- function(dt, timeStep, variable, minValue = NULL, maxValue = NULL, 
                     main = NULL, ylab = NULL, ...) {
  
  uniqueElements <- sort(unique(dt$element))
  
  xbins <- .getXBins(dt$value, minValue, maxValue)
  if (is.character(xbins)) return(xbins)
  
  .getDensity <- function(x) {
    dens <- density(x, from = xbins$rangeValues[1], to = xbins$rangeValues[2])
    data.table(x = signif(dens$x, xbins$nsignif), y = dens$y)
  }
  
  dt <- dt[, .getDensity(value), by = element]
  
  if (is.null(ylab)) ylab <- "Density"
  if (is.null(main)) main <- paste("Density of", variable)
  
  .plotStat(dt, ylab = ylab, main = main, uniqueElements = uniqueElements, ...)
  
}

.cdf <- function(dt, timeStep, variable, minValue = NULL, maxValue = NULL,
                 main = NULL, ylab = NULL, ...) {
  
  uniqueElements <- sort(unique(dt$element))
  
  xbins <- .getXBins(dt$value, minValue, maxValue)$xbins
  
  .getCDF <- function(x) {
    cdf <- sapply(xbins, function(y) mean(x <= y))
    data.table(x = xbins, y = cdf)
  }
  
  dt <- dt[, .getCDF(value), by = element]
  
  if (is.null(ylab)) ylab <- "Proportion of time steps"
  if (is.null(main)) main <- paste("Cumulated distribution of", variable)
  
  .plotStat(dt, ylab = ylab, main = main, uniqueElements = uniqueElements, ...)
  
}

.getXBins <- function(values, minValue = NULL, maxValue = NULL, size = 512) {
  if (is.null(minValue) || is.na(minValue)) {
    minValue <- min(values)
  }
  
  if (is.null(maxValue) || is.na(maxValue)) {
    maxValue <- max(values)
  }
  
  if (minValue >= maxValue) {
    return("No value to display. Please change values of minValue or unset them to display all values")
  }
  
  rangeValues <- c(minValue, maxValue)
  
  # Get the correct number of significant digits
  offset <- diff(rangeValues) * 0.1
  rangeValues <- c(rangeValues[1] - offset, rangeValues[2] + offset)
  xbins <- seq(rangeValues[1], rangeValues[2], length.out = 512)
  nsignif <- 3
  
  while(any(duplicated(signif(xbins, nsignif)))) nsignif <- nsignif + 1
  
  list(xbins = signif(xbins, nsignif), nsignif = nsignif, rangeValues = rangeValues)
}

.plotStat <- function(dt, ylab, main, colors, uniqueElements, 
                      legend, legendItemsPerRow, width, height,
                      plotConfInt = FALSE, ...) {
  dt <- dcast(dt, x ~ element, value.var = "y")
  
  if (is.null(colors)) {
    colors <- substring(rainbow(length(uniqueElements), s = 0.7, v = 0.7), 1, 7)
  } else {
    colors <- rep(colors, length.out = length(uniqueElements))
  }
  
  legendId <- sample(1e9, 1)
  
  g <- dygraph(dt, main = main, group = legendId) %>% 
    dyOptions(
      includeZero = TRUE, 
      colors = colors,
      gridLineColor = gray(0.8), 
      axisLineColor = gray(0.6), 
      axisLabelColor = gray(0.6), 
      labelsKMB = TRUE
    ) %>% 
    dyAxis("y", label = ylab, pixelsPerLabel = 60) %>% 
    dyLegend(show = "never") %>% 
    dyCallbacks(
      highlightCallback = JS_updateLegend(legendId, timeStep = "none"),
      unhighlightCallback = JS_resetLegend(legendId)
    )
  
  if (plotConfInt) {
    for (v in uniqueElements) {
      g <- g %>% dySeries(paste0(v, c("_l", "", "_u")))
    }
  }
  
  if (legend) {
    l <- tsLegend(uniqueElements, types = rep("line", length(uniqueElements)), 
                  colors = colors, legendId = legendId, legendItemsPerRow = legendItemsPerRow)
  } else l <- NULL
  
  
  combineWidgets(g, footer = l, width = width, height = height)
}
