# Copyright © 2016 RTE Réseau de transport d’électricité

#' plot time series contained in an antaresData object
#'
#' This function generates an interactive plot of an antares time series.
#'
#' @param x
#'   Object of class \code{antaresData}. Alternatively, it can be a list of
#'   \code{antaresData} objects. In this case, one chart is created for each
#'   object.
#' @param table
#'   Name of the table to display when \code{x} is an \code{antaresDataList}
#'   object.
#' @param variable
#'   Name of the variable to plot. If this argument is missing, then the
#'   function starts a shiny gadget that let the user choose the variable to
#'   represent. When the user clicks on the "Done" button", the graphic is
#'   returned by the function.
#' @param elements
#'   Vector of "element" names indicating for which elements of 'x' should the
#'   variable be plotted. For instance if the input data contains areas, then
#'   this parameter should be a vector of area names. If data contains clusters
#'   data, this parameter has to be the concatenation of the area name and the
#'   cluster name, separated by \code{" > "}. This is to prevent confusion
#'   when two clusters from different areas have the same name.
#' @param type
#'   Type of plot to draw. "ts" creates a time series plot, "barplot" creates
#'   a barplot with one bar per element representing the average value of the
#'   variable for this element. "monotone" draws the monotone curve of the
#'   variable for each element.
#' @param dateRange
#'   A vector of two dates. Only data points between these two dates are
#'   displayed. If NULL, then all data is displayed.
#' @param confInt
#'   Number between 0 and 1 indicating the size of the confidence interval to
#'   display. If it equals to 0, then confidence interval is not computed nor
#'   displayed. Used only when multiple Monte Carlo scenarios are present in
#'   the input data.
#' @param minValue
#'   Only used if parameter \code{type} is "density" or "cdf". If this parameter
#'   is set, all values that are less than \code{minValue} are removed from the
#'   graphic. This is useful to deal with variables containing a few extreme
#'   values (generally cost and price variables). If \code{minValue} is unset,
#'   all values are displayed.
#' @param maxValue
#'   Only used if parameter \code{type} is "density" or "cdf". If this parameter
#'   is set, all values not in [-minValue, maxValue] are removed from the graphic.
#'   This is useful to deal with variables containing a few extreme values
#'   (generally cost and price variables). If \code{maxValue} is 0 or unset, all
#'   values are displayed.
#' @param aggregate
#'   When multiple elements are selected, should the data be aggregated. If
#'   "none", each element is represented separetly. If "mean" values are
#'   averaged and if "sum" they are added.
#' @param colors
#'   Vector of colors
#' @param ylab
#'   Label of the Y axis.
#' @param colorScaleOpts
#'   A list of parameters that control the creation of color scales. It is used
#'   only for heatmaps. See \code{\link{colorScaleOptions}}() for available
#'   parameters.
#' @param xyCompare
#'   Use when you compare studies, can be "union" or "intersect". If union, all
#'   of mcYears in one of studies will be selectable. If intersect, only mcYears in all
#'   studies will be selectable.
#'
#'
#' @inheritParams prodStack
#'
#' @return
#' The function returns an object of class "htmlwidget". It is generated by
#' package \code{highcharter} if time step is annual or by \code{dygraphs} for
#' any other time step.It can be directly displayed in the viewer or be stored
#' in a variable for later use.
#'
#' @details
#' If the input data contains several Monte-Carlo scenarios, the function will
#' display the evolution of the average value. Moreover it will represent a
#' 95% confidence interval.
#'
#' If the input data has a annual time step, the function creates a barplot
#' instead of a line chart.
#'
#'
#' @examples
#' \dontrun{
#' setSimulationPath()
#' mydata <- readAntares("all", timeStep = "monthly")
#' plot(mydata)
#' plot(mydata, "LOAD")
#'
#' # Plot only a few areas
#' plot(mydata[area %in% c("area1", "area2", "area3")])
#'
#' # If data contains detailed results, then the function adds a confidence
#' # interval
#' dataDetailed <- readAntares("all", timeStep = "monthly", synthesis = FALSE)
#' plot(dataDetailed)
#'
#' # If the time step is annual, the function creates a barplot instead of a
#' # linechart
#' dataAnnual <- readAntares("all", timeStep = "Annual")
#' plot(dataAnnual)
#'
#' # Compare the results of two simulations
#' setSimulationPath(path1)
#' mydata1 <- readAntares("all", timeStep = "daily")
#' setSimulationPath(path2)
#' mydata2 <- readAntares("all", timeStep = "daily")
#'
#' plot(mydata1, mydata2)
#'
#' # Compare two periods for the same simulation
#' plot(mydata1, compare = "dateRange")
#'
#' # Compare two Monte-Carlo scenarios
#' detailedData <- readAntares("all", mcYears = "all")
#' plot(detailedData[mcYear == 1], detailedData[mcYear == 2])
#'
#' # To do the same thing, with antaresDataList objects, one can use 'subset'
#' detailedData <- readAntares(areas = "all", links = "all", mcYears = "all")
#' plot(subset(detailedData, mcYears = 1), subset(detailedData, mcYears = 2))
#' }
#'
#' @import rhdf5
#'
#' @export
tsPlot <- function(x, y = NULL, table = NULL, variable = NULL, elements = NULL,
                   mcYear = "average",
                   type = c("ts", "barplot", "monotone", "density", "cdf", "heatmap"),
                   dateRange = NULL,
                   confInt = 0,
                   minValue = NULL,
                   maxValue = NULL,
                   aggregate = c("none", "mean", "sum"),
                   compare = NULL,
                   compareOpts = list(),
                   interactive = getInteractivity(),
                   colors = NULL,
                   main = NULL,
                   ylab = NULL,
                   legend = TRUE,
                   legendItemsPerRow = 5,
                   colorScaleOpts = colorScaleOptions(20),
                   width = NULL, height = NULL, xyCompare = c("union","intersect"), ...) {
  table <- NULL
  xyCompare <- match.arg(xyCompare)
  type <- match.arg(type)
  aggregate <- match.arg(aggregate)
  colorScaleOpts <- do.call(colorScaleOptions, colorScaleOpts)

  init_elements <- elements
  init_dateRange <- dateRange
  isH5_init <- "simOptions" %in% class(x) && !is.null(x$h5path)



  # Generate a group number for dygraph objects
  if (!("dateRange" %in% compare)) {
    group <- sample(1e9, 1)
  } else {
    group <- NULL
  }



  processFun <- function(x, elements = NULL, dateRange = NULL) {
    assert_that(inherits(x, "antaresData"))
    x <- as.antaresDataList(x)

    lapply(x, function(x) {
      idCols <- .idCols(x)
      valueCols <- setdiff(names(x), idCols)
      timeStep <- attr(x, "timeStep")
      opts <- simOptions(x)

      dt <- x[, .(
        timeId = timeId,
        time = .timeIdToDate(timeId, attr(x, "timeStep"), simOptions(x)),
        value = 0)
        ]

      if ("cluster" %in% idCols) {
        dt$element <- paste(x$area, x$cluster, sep = " > ")
      } else if ("district" %in% idCols) {
        dt$element <- x$district
      } else if ("link" %in% idCols) {
        dt$element <- x$link
      } else if ("area" %in% idCols) {
        dt$element <- x$area
      } else stop("No Id column")

      if ("mcYear" %in% names(x)) {
        dt$mcYear <- x$mcYear
      }

      dataDateRange <- as.Date(range(dt$time))
      if (is.null(dateRange) || length(dateRange) < 2) dateRange <- dataDateRange

      uniqueElem <- sort(as.character(unique(dt$element)))
      if (is.null(elements)) {
        elements <- uniqueElem
        if (length(elements) > 5) elements <- elements[1:5]
      }

      # Function that generates the desired graphic.
      plotFun <- function(mcYear, id, variable, elements, type, confInt, dateRange,
                          minValue, maxValue, aggregate, legend) {
        if (is.null(variable)) variable <- valueCols[1]
        if (is.null(dateRange)) dateRange <- dateRange
        if (is.null(type) || !variable %in% names(x)) {
          return(combineWidgets())
        }


        dt <- .getTSData(
          x, dt,
          variable = variable, elements = elements,
          uniqueElement = uniqueElem,
          mcYear = mcYear, dateRange = dateRange, aggregate = aggregate
        )

        if (nrow(dt) == 0) return(combineWidgets("No data"))

        if(type == "ts"){
          if(!is.null(dateRange))
          {
            if(dt$time[1] > dateRange[1]){
              dt <- dt[c(NA, 1:nrow(dt))]
              dt$time[1] <- dateRange[1]
            }
            nrowTp <- nrow(dt)
            if(dt$time[nrowTp] < dateRange[2]){
              dt <- dt[c(1:nrow(dt), NA)]
              dt$time[nrowTp + 1] <- dateRange[2]
            }
          }

        }



        f <- switch(type,
                    "ts" = .plotTS,
                    "barplot" = .barplot,
                    "monotone" = .plotMonotone,
                    "density" = .density,
                    "cdf" = .cdf,
                    "heatmap" = .heatmap,
                    stop("Invalid type")
        )

        f(
          dt,
          timeStep = timeStep,
          variable = variable,
          confInt = confInt,
          minValue = minValue,
          maxValue = maxValue,
          colors = colors,
          main = if(length(main) == 1) main else main[id],
          ylab = if(length(ylab) == 1) ylab else ylab[id],
          legend = legend,
          legendItemsPerRow = legendItemsPerRow,
          width = width,
          height = height,
          opts = opts,
          colorScaleOpts = colorScaleOpts,
          group = group
        )

      }
      list(
        plotFun = plotFun,
        dt = dt,
        x = x,
        idCols = idCols,
        valueCols = valueCols,
        showConfInt = !is.null(x$mcYear) && length(unique(x$mcYear) > 1),
        dataDateRange = dataDateRange,
        dateRange = dateRange,
        uniqueElem = uniqueElem,
        uniqueMcYears = unique(x$mcYear),
        elements = elements,
        timeStep = timeStep,
        opts = opts
      )
    })
  }
  # If not in interactive mode, generate a simple graphic, else create a GUI
  # to interactively explore the data
  if (!interactive) {
    params <- antaresViz:::.getDataForComp(x, y, compare, compareOpts,
                                           processFun = processFun,
                                           elements = elements, dateRange = dateRange)

    if (is.null(table)) table <- names(params$x[[1]])[1]
    if (is.null(mcYear)) mcYear <- "average"

    return(params$x[[1]][[table]]$plotFun(mcYear, 1, variable, elements, type, confInt, dateRange,
                                          minValue, maxValue, aggregate, legend))
  }

  typeChoices <- c("time series" = "ts", "barplot", "monotone", "density", "cdf", "heatmap")
  manipulateWidget({
    print(params)
    if(is.null(params[["x"]][[max(1,.id)]][[table]])){return(combineWidgets(paste0("Table ", table, " not exists in this data")))}

    params[["x"]][[max(1,.id)]][[table]]$plotFun(mcYear, .id, variable, elements, type, confInt, dateRange, minValue,
                                                 maxValue, aggregate, legend)

  },
  x = mwSharedValue(x),
  y = mwSharedValue(y),

  ###H5
  x_Infos = mwSharedValue({
    if(!is.null(x_Infos$isH5)){
      list(dataInput = x_Infos$dataInput, isH5 = "simOptions" %in% class(x_Infos$dataInput) && !is.null(x_Infos$dataInput$h5path))

    }else{
      list(dataInput = x, isH5 = "simOptions" %in% class(x) && !is.null(x$h5path))
    }
  }),
  y_Infos = mwSharedValue({
    if(!is.null(y_Infos$isH5)){
      list(dataInput = y_Infos$dataInput, isH5 = "simOptions" %in% class(y_Infos$dataInput) && !is.null(y_Infos$dataInput$h5path))

    }else{
      list(dataInput = y, isH5 = "simOptions" %in% class(y) && !is.null(y$h5path))
    }
  }),

  paramsH5 = mwSharedValue({
    .giveParamH5(X_I = x_Infos, Y_I = y_Infos, xyCompare = xyCompare)
  }),

  H5request = mwGroup(
    timeSteph5 = mwSelect(choices = paramsH5$timeStepS, value =  paramsH5$timeStepS[1]
                          , label = "timeStep", multiple = FALSE),
    tables = mwSelect(choices = paramsH5[["tabl"]], value = {
      if(.initial) {paramsH5[["tabl"]][1]}else{NULL}
    } , label = "table", multiple = TRUE),
    mcYearh = mwSelect(choices = c(paramsH5[["mcYearS"]]), value = {
      if(.initial){paramsH5[["mcYearS"]][1]}else{NULL}
    }, label = "mcYear", multiple = TRUE)
    ,.display = x_Infos$isH5),
  table = mwSelect(
    {
      if(!is.null(params)){
        as.character(.compareopetation(lapply(params$x, function(vv){
          unique(names(vv))
        }), xyCompare))
      }
    }
    , value = {
      if(.initial) table
      else NULL
    }, .display = length(as.character(.compareopetation(lapply(params$x, function(vv){
      unique(names(vv))
    }), xyCompare))) > 1),
  mcYear = mwSelect(
    choices = {
      c("average",     if(!is.null(params)){
        as.character(.compareopetation(lapply(params$x, function(vv){
          unique(vv[[table]]$uniqueMcYears)
        }), xyCompare))
      })

      },
    value = {
      if(.initial) "average"
      else NULL
    }
  ),
  sharerequest = mwSharedValue({
    list(timeSteph5_l = timeSteph5, mcYearh_l = mcYearh, tables_l = tables)
  }),

  x_tranform = mwSharedValue({
    .giveH5DataToApi(sharerequest, x_Infos)
  }),
  y_tranform = mwSharedValue({
    .giveH5DataToApi(sharerequest, y_Infos)
  }),

  variable = mwSelect(

    choices = {
      if(!is.null(params)){
        as.character(.compareopetation(lapply(params$x, function(vv){
          unique(vv[[table]]$valueCols)
        }), xyCompare))
      }
    },

    value = {
      if(.initial) variable
      else NULL
    }
  ),
  type = mwSelect(
    choices = {
      if (timeStepdataload == "annual") "barplot"
      else if (timeStepdataload %in% c("hourly", "daily")) typeChoices
      else typeChoices[1:5]
    },
    value = {
      if(.initial) type
      else NULL
    },
    .display = timeStepdataload != "annual"
  ),

  dateRange = mwDateRange(value = {
    if(.initial){
      res <- NULL
      if(!is.null(params) & ! is.null(table)){
      res <- c(.giveDateInfos(yD = y_Infos$dataInput, param = params, xyCompare = xyCompare, "min", tabl = table),
               .giveDateInfos(yD = y_Infos$dataInput, param = params, xyCompare = xyCompare, "max", tabl = table))
      }
      res
    }else{NULL}
  }, min =
  {
    if(!is.null(params) & ! is.null(table)){
    .giveDateInfos(yD = y_Infos$dataInput, params = params, xyCompare = xyCompare, "min", tabl = table)
    }
  }
  ,
  max =
  {
    if(!is.null(params) & ! is.null(table)){
    .giveDateInfos(yD = y_Infos$dataInput, params = params, xyCompare = xyCompare, "max",  tabl = table)
    }

  },.display = timeStepdataload != "annual"),
  confInt = mwSlider(0, 1, confInt, step = 0.01, label = "confidence interval",
                     .display = params$x[[max(1,.id)]][[table]]$showConfInt & mcYear == "average"),
  minValue = mwNumeric(minValue, "min value", .display = type %in% c("density", "cdf")),
  maxValue = mwNumeric(maxValue, "max value", .display = type %in% c("density", "cdf")),
  elements = mwSelect(
    choices = {
      c("all", if(!is.null(params)){
        as.character(.compareopetation(lapply(params$x, function(vv){
          unique(vv[[table]]$uniqueElem)
        }), xyCompare))
      })#{params$x[[max(1,.id)]][[table]]$uniqueElem)

      },
    value = {
      if(.initial) {     as.character(.compareopetation(lapply(params$x, function(vv){
        unique(vv[[table]]$uniqueElem)
      }), xyCompare))[1]}
    },
    multiple = TRUE
  ),
  aggregate = mwSelect(c("none", "mean", "sum"),
                       value ={
                         if(.initial) aggregate
                         else NULL
                       }),
  legend = mwCheckbox(legend, .display = type %in% c("ts", "density", "cdf")),


  timeStepdataload = mwSharedValue({
    attributes(x_tranform)$timeStep
  }),
  params = mwSharedValue({
    prm <- .getDataForComp(x_tranform, y_tranform, compare, compareOpts,
                           processFun = processFun,
                           elements = init_elements, dateRange = init_dateRange)
    prm
  }),
  .compare = {
    if(is.null(compare))
    {
      if(is.null(y)){

        NULL
      }else{""}
    }else{
      compare
    }
  },
  .compareOpts = {
    if(is.null(compare) && is.null(y))
    {
      compareOptions()
    }else{
      #to review (temp version)
      list(ncharts = 2, ncol = 1, nrow = 2)
    }
  },
  ...
  )

}